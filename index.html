<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cloudflare 优选实时测速（Ping + TCPing）</title>
    <style>
      :root {
        --bg: #f4f7fb;
        --text: #1f2937;
        --muted: #6b7280;
        --primary: #2563eb;
        --card: #fff;
        --border: #e5e7eb;
        --ok: #16a34a;
        --warn: #d97706;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at 10% -10%, #dbeafe 0, transparent 35%), var(--bg);
      }
      .wrap { max-width: 980px; margin: 0 auto; padding: 24px 16px 36px; }
      h1 { margin: 0; font-size: clamp(1.5rem, 4vw, 2.1rem); }
      .sub { color: var(--muted); margin: 8px 0 20px; }

      .cards { display: grid; gap: 14px; }
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 6px 20px rgba(15, 23, 42, 0.05);
      }
      .head {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }
      .domain { font-weight: 700; word-break: break-all; }
      .tag { color: var(--muted); font-size: 0.9rem; margin-top: 4px; }

      .metrics {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        margin-top: 12px;
      }
      .metric {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
      }
      .label { font-size: 0.8rem; color: var(--muted); }
      .value { font-weight: 800; font-size: 1.1rem; margin-top: 6px; }
      .value.ok { color: var(--ok); }
      .value.warn { color: var(--warn); }
      .detail { font-size: 0.82rem; color: var(--muted); margin-top: 6px; }

      .controls {
        margin-top: 16px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      button {
        border-radius: 10px;
        border: 1px solid transparent;
        padding: 10px 14px;
        font-weight: 600;
        cursor: pointer;
      }
      .btn-main { background: var(--primary); color: #fff; }
      .btn-ghost { background: #fff; border-color: var(--border); color: var(--text); }

      .summary {
        margin-top: 16px;
        background: #fff;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px 14px;
        color: var(--muted);
      }
      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
      }
      .summary strong { color: var(--primary); }

      /* 可折叠：我们的优势（技术版） */
      .advantages { margin-top: 16px; }
      .adv-details {
        background: #fff;
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
      }
      .adv-details > summary {
        list-style: none;
        cursor: pointer;
        padding: 12px 14px;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: space-between;
        user-select: none;
      }
      .adv-details > summary::-webkit-details-marker { display: none; }
      .adv-details > summary::after {
        content: "展开";
        font-size: 0.86rem;
        color: var(--muted);
        font-weight: 600;
      }
      .adv-details[open] > summary::after { content: "收起"; }

      .adv-body { padding: 0 14px 14px; }
      .adv-note {
        margin: 0 0 10px;
        color: var(--muted);
        font-size: 0.88rem;
      }
      .adv-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 10px;
      }
      .adv-item {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        background: #fcfdff;
      }
      .adv-item h3 {
        margin: 0 0 6px;
        font-size: 0.95rem;
      }
      .adv-item p {
        margin: 0;
        color: #475569;
        font-size: 0.86rem;
        line-height: 1.55;
      }
      .adv-live {
        margin-top: 10px;
        border: 1px dashed #cbd5e1;
        border-radius: 10px;
        padding: 10px 12px;
        background: #f8fafc;
        color: #334155;
        font-size: 0.88rem;
      }
      .adv-live strong { color: var(--primary); }

      @media (max-width: 640px) {
        .metrics { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <h1>☁️ Cloudflare 优选实时测速（Ping + TCPing）</h1>
      <p class="sub">
        显示的是优选域名，实际请求的是指定的后端 Pages 地址。每 2 秒并行请求探测文件
        <code>probe-1kb.txt</code>。
      </p>

      <section class="cards" id="cards"></section>

      <div class="controls">
        <button class="btn-main" id="toggle">暂停实时测速</button>
        <button class="btn-ghost" id="reset">重置统计</button>
      </div>

      <p class="summary" id="summary"><span class="status-dot"></span>初始化中...</p>

      <section class="advantages">
        <details class="adv-details" open>
          <summary>我们的优势（技术版）</summary>
          <div class="adv-body">
            <p class="adv-note">
              基于你提供的两张“多地 Ping 值测试”对比图（cf.te.lezi.chat vs youxuan.cf.090227.xyz）整理，
              侧重延迟分布与节点稳定性表现。
            </p>

            <div class="adv-grid">
              <article class="adv-item">
                <h3>低延迟覆盖更广</h3>
                <p>
                  从全国分布图趋势看，cf.te.lezi.chat 的低延迟区域更连续，说明跨地区访问时命中较优链路的概率更高。
                </p>
              </article>

              <article class="adv-item">
                <h3>中高延迟节点占比更低</h3>
                <p>
                  对比列表中，中高延迟档位的节点压力相对更小，跨网/跨省访问时更不容易出现“突然变慢”。
                </p>
              </article>

              <article class="adv-item">
                <h3>尾延迟控制更稳</h3>
                <p>
                  高延迟异常点更少、更分散，说明在弱网或高峰时段下，长尾响应时间的可控性更好。
                </p>
              </article>

              <article class="adv-item">
                <h3>对业务更友好</h3>
                <p>
                  更快的首包和更稳的 RTT 对网页打开、API 调用、文件下载与长连接场景都有直接收益。
                </p>
              </article>
            </div>

            <div class="adv-live" id="advLive">实时补充：样本采集中...</div>
          </div>
        </details>
      </section>
    </main>

    <script>
      const endpoints = [
        { name: "我的优选", domain: "cf.te.lezi.chat", target: "pages.te.lezi.chat" },
        { name: "对照组", domain: "youxuan.cf.090227.xyz", target: "090227.te.lezi.chat" }
      ];

      const INTERVAL_MS = 2000;
      const TIMEOUT_MS = 4000;
      const HISTORY_LIMIT = 20;
      const FAST_THRESHOLD = 350;
      const TIE_EPSILON = 1;

      const cardsEl = document.querySelector("#cards");
      const summaryEl = document.querySelector("#summary");
      const toggleBtn = document.querySelector("#toggle");
      const resetBtn = document.querySelector("#reset");
      const advLiveEl = document.querySelector("#advLive");

      function initNode() {
        return {
          ping: { history: [], fails: 0, last: undefined },   // undefined=待测试, null=超时
          tcping: { history: [], fails: 0, last: undefined }
        };
      }

      const state = new Map(endpoints.map((e) => [e.domain, initNode()]));

      let running = false;
      let inFlight = false;
      let loopTimer = null;
      let generation = 0;

      function avg(values) {
        return values.length ? values.reduce((a, b) => a + b, 0) / values.length : null;
      }

      function buildRows() {
        return endpoints.map((e) => ({
          domain: e.domain,
          pingAvg: avg(state.get(e.domain).ping.history),
          tcpAvg: avg(state.get(e.domain).tcping.history)
        }));
      }

      function renderCards() {
        cardsEl.innerHTML = endpoints.map((e) => `
          <article class="card">
            <div class="head">
              <div>
                <div class="domain">${e.domain}</div>
                <div class="tag">${e.name} (实际请求: ${e.target})</div>
              </div>
            </div>
            <div class="metrics">
              <div class="metric">
                <div class="label">Ping（HTTP RTT）</div>
                <div class="value" data-value="${e.domain}-ping">待测试</div>
                <div class="detail" data-detail="${e.domain}-ping">样本 0｜平均 -｜失败 0</div>
              </div>
              <div class="metric">
                <div class="label">TCPing（HTTPS:443）</div>
                <div class="value" data-value="${e.domain}-tcping">待测试</div>
                <div class="detail" data-detail="${e.domain}-tcping">样本 0｜平均 -｜失败 0</div>
              </div>
            </div>
          </article>
        `).join("");
      }

      function renderMetric(domain, type) {
        const item = state.get(domain)?.[type];
        const valueEl = document.querySelector(`[data-value="${domain}-${type}"]`);
        const detailEl = document.querySelector(`[data-detail="${domain}-${type}"]`);
        if (!item || !valueEl || !detailEl) return;

        valueEl.classList.remove("ok", "warn");

        if (item.last === undefined) {
          valueEl.textContent = "待测试";
        } else if (item.last === null) {
          valueEl.textContent = "超时";
          valueEl.classList.add("warn");
        } else {
          valueEl.textContent = `${item.last.toFixed(1)} ms`;
          valueEl.classList.add(item.last < FAST_THRESHOLD ? "ok" : "warn");
        }

        const a = avg(item.history);
        detailEl.textContent = `样本 ${item.history.length}｜平均 ${a === null ? "-" : `${a.toFixed(1)} ms`}｜失败 ${item.fails}`;
      }

      function renderAdvLive(preRows = null) {
        if (!advLiveEl) return;

        const rows = preRows ?? buildRows();
        const pingValid = rows.filter((r) => typeof r.pingAvg === "number").sort((a, b) => a.pingAvg - b.pingAvg);
        const tcpValid = rows.filter((r) => typeof r.tcpAvg === "number").sort((a, b) => a.tcpAvg - b.tcpAvg);

        const failRows = endpoints.map((e) => ({
          domain: e.domain,
          fails: state.get(e.domain).ping.fails + state.get(e.domain).tcping.fails
        })).sort((a, b) => a.fails - b.fails);

        if (pingValid.length < 2 || tcpValid.length < 2) {
          advLiveEl.innerHTML = "实时补充：样本采集中，等待两个域名都形成有效均值。";
          return;
        }

        const pingLead = pingValid[1].pingAvg - pingValid[0].pingAvg;
        const tcpLead = tcpValid[1].tcpAvg - tcpValid[0].tcpAvg;

        const pingText = pingLead < TIE_EPSILON
          ? `Ping 基本持平（< ${TIE_EPSILON} ms）`
          : `Ping 当前领先 <strong>${pingValid[0].domain}</strong>（约 ${pingLead.toFixed(1)} ms）`;

        const tcpText = tcpLead < TIE_EPSILON
          ? `TCPing 基本持平（< ${TIE_EPSILON} ms）`
          : `TCPing 当前领先 <strong>${tcpValid[0].domain}</strong>（约 ${tcpLead.toFixed(1)} ms）`;

        let failText = "超时次数当前持平";
        if (failRows.length >= 2 && failRows[0].fails !== failRows[1].fails) {
          failText = `超时次数更少：<strong>${failRows[0].domain}</strong>`;
        }

        advLiveEl.innerHTML = `实时补充：${pingText}，${tcpText}；${failText}。`;
      }

      function renderSummary() {
        const rows = buildRows();
        const pingValid = rows.filter((r) => typeof r.pingAvg === "number").sort((a, b) => a.pingAvg - b.pingAvg);
        const tcpValid = rows.filter((r) => typeof r.tcpAvg === "number").sort((a, b) => a.tcpAvg - b.tcpAvg);
        const dotColor = running ? "var(--ok)" : "var(--muted)";

        if (pingValid.length < 2 || tcpValid.length < 2) {
          summaryEl.innerHTML = `<span class="status-dot" style="background:${dotColor}"></span>${running ? "实时测速中" : "已暂停"}：等待两个域名都出现有效 Ping/TCPing 样本...`;
          renderAdvLive(rows);
          return;
        }

        const pingLead = pingValid[1].pingAvg - pingValid[0].pingAvg;
        const tcpLead = tcpValid[1].tcpAvg - tcpValid[0].tcpAvg;

        const pingText = pingLead < TIE_EPSILON
          ? `Ping 基本持平（差 < ${TIE_EPSILON} ms）`
          : `Ping 更快 <strong>${pingValid[0].domain}</strong>（约 ${pingLead.toFixed(1)} ms）`;

        const tcpText = tcpLead < TIE_EPSILON
          ? `TCPing 基本持平（差 < ${TIE_EPSILON} ms）`
          : `TCPing 更快 <strong>${tcpValid[0].domain}</strong>（约 ${tcpLead.toFixed(1)} ms）`;

        summaryEl.innerHTML = `<span class="status-dot" style="background:${dotColor}"></span>${running ? "实时测速中" : "已暂停"}：${pingText}，${tcpText}。`;
        renderAdvLive(rows);
      }

      async function timedFetch(url, options = {}) {
        const start = performance.now();
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), TIMEOUT_MS);

        try {
          await fetch(url, {
            mode: "no-cors",
            cache: "no-store",
            signal: controller.signal,
            ...options
          });
          return performance.now() - start;
        } catch {
          return null;
        } finally {
          clearTimeout(t);
        }
      }

      function measurePing(target) {
        return timedFetch(`https://${target}/probe-1kb.txt?ping=${Date.now()}-${Math.random()}`);
      }

      // 浏览器无法做真实 TCP SYN ping；这里是 HTTPS 建连+请求耗时近似
      function measureTcping(target) {
        return timedFetch(
          `https://${target}/probe-1kb.txt?tcping=${Date.now()}-${Math.random()}`,
          { method: "HEAD" }
        );
      }

      function updateMetric(item, latency) {
        item.last = latency;
        if (latency === null) {
          item.fails += 1;
          return;
        }
        item.history.push(latency);
        if (item.history.length > HISTORY_LIMIT) item.history.shift();
      }

      async function runRound() {
        if (inFlight) return;
        inFlight = true;
        const myGeneration = generation;

        try {
          const result = await Promise.all(
            endpoints.map(async (e) => {
              const [ping, tcping] = await Promise.all([
                measurePing(e.target),
                measureTcping(e.target)
              ]);
              return { domain: e.domain, ping, tcping };
            })
          );

          if (myGeneration !== generation) return;

          for (const row of result) {
            const node = state.get(row.domain);
            if (!node) continue;
            updateMetric(node.ping, row.ping);
            updateMetric(node.tcping, row.tcping);
            renderMetric(row.domain, "ping");
            renderMetric(row.domain, "tcping");
          }

          renderSummary();
        } finally {
          inFlight = false;
        }
      }

      async function loop() {
        if (!running) return;
        await runRound();
        if (running) loopTimer = setTimeout(loop, INTERVAL_MS);
      }

      function start() {
        if (running) return;
        running = true;
        toggleBtn.textContent = "暂停实时测速";
        renderSummary();
        loop();
      }

      function stop() {
        if (!running) return;
        running = false;
        generation += 1;

        if (loopTimer) {
          clearTimeout(loopTimer);
          loopTimer = null;
        }

        toggleBtn.textContent = "继续实时测速";
        renderSummary();
      }

      function reset() {
        generation += 1;
        for (const e of endpoints) {
          state.set(e.domain, initNode());
          renderMetric(e.domain, "ping");
          renderMetric(e.domain, "tcping");
        }
        renderSummary();
      }

      toggleBtn.addEventListener("click", () => (running ? stop() : start()));
      resetBtn.addEventListener("click", reset);

      renderCards();
      reset();
      start();
    </script>
  </body>
</html>
