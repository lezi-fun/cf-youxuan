<script>
  const endpoints = [
    { name: "我的优选", domain: "cf.te.lezi.chat", target: "pages.te.lezi.chat" },
    { name: "对照组", domain: "youxuan.cf.090227.xyz", target: "090227.te.lezi.chat" }
  ];

  const INTERVAL_MS = 2000;
  const TIMEOUT_MS = 4000;
  const HISTORY_LIMIT = 20;
  const FAST_THRESHOLD = 350; // ms
  const TIE_EPSILON = 1; // 1ms 以内视为持平

  const cardsEl = document.querySelector("#cards");
  const summaryEl = document.querySelector("#summary");
  const toggleBtn = document.querySelector("#toggle");
  const resetBtn = document.querySelector("#reset");

  function initNode() {
    return {
      ping: { history: [], fails: 0, last: undefined },   // undefined=未测试, null=超时
      tcping: { history: [], fails: 0, last: undefined }
    };
  }

  const state = new Map(endpoints.map((e) => [e.domain, initNode()]));

  let running = false;
  let inFlight = false;
  let loopTimer = null;

  function avg(values) {
    return values.length ? values.reduce((a, b) => a + b, 0) / values.length : null;
  }

  function renderCards() {
    cardsEl.innerHTML = endpoints
      .map(
        (e) => `
      <article class="card">
        <div class="head">
          <div>
            <div class="domain">${e.domain}</div>
            <div class="tag">${e.name} (实际请求: ${e.target})</div>
          </div>
        </div>
        <div class="metrics">
          <div class="metric">
            <div class="label">Ping（HTTP RTT）</div>
            <div class="value" data-value="${e.domain}-ping">待测试</div>
            <div class="detail" data-detail="${e.domain}-ping">样本 0｜平均 -｜失败 0</div>
          </div>
          <div class="metric">
            <div class="label">TCPing（HTTPS:443）</div>
            <div class="value" data-value="${e.domain}-tcping">待测试</div>
            <div class="detail" data-detail="${e.domain}-tcping">样本 0｜平均 -｜失败 0</div>
          </div>
        </div>
      </article>
    `
      )
      .join("");
  }

  function renderMetric(domain, type) {
    const item = state.get(domain)?.[type];
    const valueEl = document.querySelector(`[data-value="${domain}-${type}"]`);
    const detailEl = document.querySelector(`[data-detail="${domain}-${type}"]`);
    if (!item || !valueEl || !detailEl) return;

    valueEl.classList.remove("ok", "warn");

    if (item.last === undefined) {
      valueEl.textContent = "待测试";
    } else if (item.last === null) {
      valueEl.textContent = "超时";
      valueEl.classList.add("warn");
    } else {
      valueEl.textContent = `${item.last.toFixed(1)} ms`;
      valueEl.classList.add(item.last < FAST_THRESHOLD ? "ok" : "warn");
    }

    const a = avg(item.history);
    detailEl.textContent = `样本 ${item.history.length}｜平均 ${
      a === null ? "-" : `${a.toFixed(1)} ms`
    }｜失败 ${item.fails}`;
  }

  function renderSummary() {
    const rows = endpoints.map((e) => ({
      domain: e.domain,
      pingAvg: avg(state.get(e.domain).ping.history),
      tcpAvg: avg(state.get(e.domain).tcping.history)
    }));

    const pingValid = rows
      .filter((r) => typeof r.pingAvg === "number")
      .sort((a, b) => a.pingAvg - b.pingAvg);

    const tcpValid = rows
      .filter((r) => typeof r.tcpAvg === "number")
      .sort((a, b) => a.tcpAvg - b.tcpAvg);

    if (pingValid.length < 2 || tcpValid.length < 2) {
      summaryEl.innerHTML = `<span class="status-dot"></span>${running ? "实时测速中" : "已暂停"}：等待两个域名都出现有效 Ping/TCPing 样本...`;
      return;
    }

    const pingLead = pingValid[1].pingAvg - pingValid[0].pingAvg;
    const tcpLead = tcpValid[1].tcpAvg - tcpValid[0].tcpAvg;

    const pingText =
      pingLead < TIE_EPSILON
        ? `Ping 基本持平（差 < ${TIE_EPSILON} ms）`
        : `Ping 更快 <strong>${pingValid[0].domain}</strong>（约 ${pingLead.toFixed(1)} ms）`;

    const tcpText =
      tcpLead < TIE_EPSILON
        ? `TCPing 基本持平（差 < ${TIE_EPSILON} ms）`
        : `TCPing 更快 <strong>${tcpValid[0].domain}</strong>（约 ${tcpLead.toFixed(1)} ms）`;

    summaryEl.innerHTML = `<span class="status-dot"></span>${running ? "实时测速中" : "已暂停"}：${pingText}，${tcpText}。`;
  }

  async function timedFetch(url, options = {}) {
    const start = performance.now();
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), TIMEOUT_MS);

    try {
      await fetch(url, {
        mode: "no-cors",
        cache: "no-store",
        signal: controller.signal,
        ...options
      });
      return performance.now() - start;
    } catch {
      return null;
    } finally {
      clearTimeout(t);
    }
  }

  async function measurePing(target) {
    return timedFetch(`https://${target}/probe-1kb.txt?ping=${Date.now()}-${Math.random()}`);
  }

  async function measureTcping(target) {
    // 浏览器里无法做真正 TCP SYN ping，这里是 HTTPS 建连+请求耗时近似值
    return timedFetch(
      `https://${target}/probe-1kb.txt?tcping=${Date.now()}-${Math.random()}`,
      { method: "HEAD" }
    );
  }

  function updateMetric(item, latency) {
    item.last = latency;
    if (latency === null) {
      item.fails += 1;
      return;
    }
    item.history.push(latency);
    if (item.history.length > HISTORY_LIMIT) item.history.shift();
  }

  async function runRound() {
    if (inFlight) return; // 防止重入
    inFlight = true;

    try {
      const result = await Promise.all(
        endpoints.map(async (e) => {
          // 同一端点内并行测量
          const [ping, tcping] = await Promise.all([
            measurePing(e.target),
            measureTcping(e.target)
          ]);
          return { domain: e.domain, ping, tcping };
        })
      );

      for (const row of result) {
        const node = state.get(row.domain);
        if (!node) continue;
        updateMetric(node.ping, row.ping);
        updateMetric(node.tcping, row.tcping);
        renderMetric(row.domain, "ping");
        renderMetric(row.domain, "tcping");
      }

      renderSummary();
    } finally {
      inFlight = false;
    }
  }

  async function loop() {
    if (!running) return;
    await runRound();
    if (running) {
      loopTimer = setTimeout(loop, INTERVAL_MS); // 上一轮结束后再等待，避免堆积
    }
  }

  function start() {
    if (running) return;
    running = true;
    toggleBtn.textContent = "暂停实时测速";
    renderSummary();
    loop();
  }

  function stop() {
    if (!running) return;
    running = false;
    if (loopTimer) {
      clearTimeout(loopTimer);
      loopTimer = null;
    }
    toggleBtn.textContent = "继续实时测速";
    renderSummary();
  }

  function reset() {
    for (const e of endpoints) {
      state.set(e.domain, initNode());
      renderMetric(e.domain, "ping");
      renderMetric(e.domain, "tcping");
    }
    renderSummary();
  }

  toggleBtn.addEventListener("click", () => (running ? stop() : start()));
  resetBtn.addEventListener("click", reset);

  renderCards();
  reset();
  start();
</script>
